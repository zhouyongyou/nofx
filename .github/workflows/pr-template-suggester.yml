name: PR Template Suggester

on:
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  pull-requests: write
  contents: read

jobs:
  suggest-template:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Analyze PR files and auto-apply template
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            let goFiles = 0, jsFiles = 0, tsFiles = 0, mdFiles = 0, otherFiles = 0;

            for (const file of files) {
              const filename = file.filename.toLowerCase();
              if (filename.endsWith('.go')) goFiles++;
              else if (filename.endsWith('.js') || filename.endsWith('.jsx')) jsFiles++;
              else if (filename.endsWith('.ts') || filename.endsWith('.tsx') || filename.endsWith('.vue')) tsFiles++;
              else if (filename.endsWith('.md')) mdFiles++;
              else otherFiles++;
            }

            const totalFiles = goFiles + jsFiles + tsFiles + mdFiles + otherFiles;
            if (totalFiles === 0) { console.log('No files changed'); return; }

            let suggestedTemplate = null, templateEmoji = '', templateLabel = '';

            if (goFiles / totalFiles > 0.5) {
              suggestedTemplate = 'backend'; templateEmoji = 'ğŸ”§'; templateLabel = 'backend';
            } else if ((jsFiles + tsFiles) / totalFiles > 0.5) {
              suggestedTemplate = 'frontend'; templateEmoji = 'ğŸ¨'; templateLabel = 'frontend';
            } else if (mdFiles / totalFiles > 0.7) {
              suggestedTemplate = 'docs'; templateEmoji = 'ğŸ“'; templateLabel = 'documentation';
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            const prBody = pr.body || '';
            const usesBackendTemplate = prBody.includes('Pull Request - Backend');
            const usesFrontendTemplate = prBody.includes('Pull Request - Frontend');
            const usesDocsTemplate = prBody.includes('Pull Request - Documentation');
            const usesGeneralTemplate = prBody.includes('Pull Request - General');
            const usingDefaultTemplate = !usesBackendTemplate && !usesFrontendTemplate && !usesDocsTemplate && !usesGeneralTemplate;

            if (templateLabel) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: [templateLabel]
                });
                console.log('Added label: ' + templateLabel);
              } catch (error) {
                console.log('Label might not exist, skipping...');
              }
            }

            function isPRBodyEmpty(body) {
              if (!body || body.trim().length < 100) return true;
              const hasEmptyDescription = body.includes('**English:**') && body.match(/\*\*English:\*\*\s*\n\s*\n\s*\n/);
              const hasEmptyChanges = body.includes('å…·ä½“å˜æ›´') && body.match(/\*\*ä¸­æ–‡ï¼š\*\*\s*\n\s*-\s*\n\s*-\s*\n/);
              if (hasEmptyDescription || hasEmptyChanges) return true;
              const descMatch = body.match(/\*\*English:\*\*[ï½œ|]\s*\*\*ä¸­æ–‡ï¼š\*\*\s*\n\s*(.+)/);
              if (!descMatch || descMatch[1].trim().length < 10) return true;
              return false;
            }

            if (suggestedTemplate && usingDefaultTemplate) {
              const shouldAutoApply = isPRBodyEmpty(prBody);
              const templatePath = '.github/PULL_REQUEST_TEMPLATE/' + suggestedTemplate + '.md';

              if (shouldAutoApply) {
                try {
                  const { data: templateFile } = await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: templatePath,
                    ref: context.payload.pull_request.head.ref
                  });

                  const templateContent = Buffer.from(templateFile.content, 'base64').toString('utf-8');

                  await github.rest.pulls.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.issue.number,
                    body: templateContent
                  });

                  console.log('Auto-applied ' + suggestedTemplate + ' template');

                  let fileStats = [];
                  if (goFiles > 0) fileStats.push('- ğŸ”§ Go files: ' + goFiles);
                  if (jsFiles > 0) fileStats.push('- ğŸ¨ JavaScript files: ' + jsFiles);
                  if (tsFiles > 0) fileStats.push('- ğŸ¨ TypeScript files: ' + tsFiles);
                  if (mdFiles > 0) fileStats.push('- ğŸ“ Markdown files: ' + mdFiles);
                  if (otherFiles > 0) fileStats.push('- ğŸ“¦ Other files: ' + otherFiles);
                  const fileStatsText = fileStats.join('\n');

                  const notifyComment = '## ' + templateEmoji + ' å·²è‡ªåŠ¨åº”ç”¨ä¸“ç”¨æ¨¡æ¿ | Auto-Applied Template\n\n' +
                    'æ£€æµ‹åˆ°æ‚¨çš„PRä¸»è¦åŒ…å« **' + suggestedTemplate + '** ç›¸å…³çš„å˜æ›´ï¼Œç³»ç»Ÿå·²è‡ªåŠ¨ä¸ºæ‚¨åº”ç”¨ç›¸åº”çš„æ¨¡æ¿ã€‚\n\n' +
                    'Detected that your PR primarily contains **' + suggestedTemplate + '** changes. The appropriate template has been automatically applied.\n\n' +
                    '**æ–‡ä»¶ç»Ÿè®¡ | File Statistics**\n' + fileStatsText + '\n\n' +
                    '**å·²åº”ç”¨æ¨¡æ¿ | Applied Template**\n`' + templatePath + '`\n\n' +
                    'âœ¨ æ‚¨ç°åœ¨å¯ä»¥ç›´æ¥åœ¨PRæè¿°ä¸­å¡«å†™ç›¸å…³ä¿¡æ¯äº†ï¼\n\n' +
                    'âœ¨ You can now fill in the relevant information in the PR description!';

                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: notifyComment
                  });

                } catch (error) {
                  console.log('Failed to fetch or apply template: ' + error.message);
                  const templateUrl = 'https://raw.githubusercontent.com/' + context.repo.owner + '/' + context.repo.repo + '/dev/.github/PULL_REQUEST_TEMPLATE/' + suggestedTemplate + '.md';
                  const fallbackComment = '## ' + templateEmoji + ' å»ºè®®ä½¿ç”¨ä¸“ç”¨æ¨¡æ¿ | Suggested Template\n\n' +
                    'æ‚¨çš„PRä¸»è¦åŒ…å« **' + suggestedTemplate + '** ç›¸å…³çš„å˜æ›´ã€‚\n\n' +
                    '**æ¨èæ¨¡æ¿ | Recommended Template:** `.github/PULL_REQUEST_TEMPLATE/' + suggestedTemplate + '.md`\n\n' +
                    '**å¦‚ä½•ä½¿ç”¨ | How to use:** [ç‚¹å‡»æŸ¥çœ‹æ¨¡æ¿å†…å®¹](' + templateUrl + ')';

                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: fallbackComment
                  });
                }
              } else {
                console.log('PR body has content, sending suggestion only');

                let fileStats = [];
                if (goFiles > 0) fileStats.push('- ğŸ”§ Go files: ' + goFiles);
                if (jsFiles > 0) fileStats.push('- ğŸ¨ JavaScript files: ' + jsFiles);
                if (tsFiles > 0) fileStats.push('- ğŸ¨ TypeScript files: ' + tsFiles);
                if (mdFiles > 0) fileStats.push('- ğŸ“ Markdown files: ' + mdFiles);
                if (otherFiles > 0) fileStats.push('- ğŸ“¦ Other files: ' + otherFiles);
                const fileStatsText = fileStats.join('\n');

                const templateUrl = 'https://raw.githubusercontent.com/' + context.repo.owner + '/' + context.repo.repo + '/dev/.github/PULL_REQUEST_TEMPLATE/' + suggestedTemplate + '.md';

                const comment = '## ' + templateEmoji + ' å»ºè®®ä½¿ç”¨ä¸“ç”¨æ¨¡æ¿ | Suggested Template\n\n' +
                  'æ‚¨çš„PRä¸»è¦åŒ…å« **' + suggestedTemplate + '** ç›¸å…³çš„å˜æ›´ã€‚æˆ‘ä»¬å»ºè®®ä½¿ç”¨æ›´é€‚åˆçš„æ¨¡æ¿ä»¥ç®€åŒ–å¡«å†™ã€‚\n\n' +
                  'Your PR primarily contains **' + suggestedTemplate + '** changes. We suggest using a more suitable template to simplify filling.\n\n' +
                  '**æ–‡ä»¶ç»Ÿè®¡ | File Statistics**\n' + fileStatsText + '\n\n' +
                  '**æ¨èæ¨¡æ¿ | Recommended Template**\n```\n.github/PULL_REQUEST_TEMPLATE/' + suggestedTemplate + '.md\n```\n\n' +
                  '**å¦‚ä½•ä½¿ç”¨ | How to use**\n' +
                  '1. ç¼–è¾‘PRæè¿° | Edit PR description\n' +
                  '2. å¤åˆ¶ [' + suggestedTemplate + ' æ¨¡æ¿å†…å®¹](' + templateUrl + ') | Copy [' + suggestedTemplate + ' template content](' + templateUrl + ')\n' +
                  '3. æˆ–åœ¨åˆ›å»ºPRæ—¶ä½¿ç”¨URLå‚æ•° | Or use URL parameter when creating PR\n' +
                  '   `?template=' + suggestedTemplate + '.md`\n\n' +
                  '_è¿™æ˜¯ä¸€ä¸ªè‡ªåŠ¨å»ºè®®ï¼Œæ‚¨å¯ä»¥ç»§ç»­ä½¿ç”¨å½“å‰æ¨¡æ¿ã€‚_\n\n' +
                  '_This is an automated suggestion. You may continue using the current template._';

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: comment
                });
              }
            } else if (suggestedTemplate && !usingDefaultTemplate) {
              console.log('PR already uses a specific template');
            } else {
              console.log('No specific template suggestion needed - mixed changes');
            }
